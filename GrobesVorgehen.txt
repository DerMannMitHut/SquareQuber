# Canvas-Variante (performant, ein `<canvas>`, Pointer Events)

## Mockup (grobe Skizze)

```
┌──────────────────────── Hauptleiste ────────────────────────┐
│  ▢ Neu  ▢ Rückgängig  ▢ Raster an/aus  ▢ Zoom  [Fortschritt]│
└──────────────────────────────────────────────────────────────┘
┌───────────────────────────────┬──────────────────────────────┐
│           36×36 Canvas        │   Teilevorrat                │
│  ░ Raster, Schatten/Preview   │   [■1] x1    [■2] x2         │
│  ░ Geister-Snapping           │   [■3] x3    …   [■8] x8     │
│  ░ Kollisions-Feedback        │   (Ziehen aufs Board)        │
└───────────────────────────────┴──────────────────────────────┘
   Statusleiste: „Gefüllte Zellen: 0/1296 • Überlappung: Nein“
```

## Architektur (High Level)

* **State (Model)**

  * `GameState`: globale, serialisierbare Daten (Skalierung, Modus, Fortschritt).
  * `Board`: 36×36 Integer-Array `cells` (0 = frei, >0 = pieceId).
  * `Piece`: `{ id, size, x, y, placed, w=size, h=size }` (Board-Koordinaten in Zellen).
  * `Inventory`: Liste aller Pieces (1×1, 2×2×2, …, 8×8×8), jeweils mit `placed`-Flag.
* **Controller**

  * `DragController`: Pointer Events (down/move/up), Drag-Offset in Pixel, Umrechnung in Zell-Koordinaten, Snap.
  * `CollisionSystem`: prüft `inBounds` & `overlap` (nur die Zielregion, O(s²) pro Drop).
  * `Undo/Redo`: Stack mit Deltas (vorher/nachher Koordinaten + belegte Zellen).
* **View**

  * `Renderer`: Ein Canvas (HiDPI-aware), Schichten:

    1. Raster/Guides,
    2. gelegte Teile,
    3. Drag-Preview (grün/rot je Validität).
  * `UIPanel`: Vorrat (kleine Canvas-Thumbnails), Buttons, Fortschrittsanzeige.
* **Utilities**

  * `Geometry`: Pixel↔Zelle (`cellSize = floor(min(…)/36)`), `gridSnap`.
  * `Serialize`: Export/Import als JSON (optional `localStorage`, keine externe DB).

## Kernlogik (wichtige Details)

* **Snapping**: Drop nur auf ganzzahlige Zell-Koordinaten; Top-Left eines Teils = Zell-Anker.
* **Overlap & Bounds**: vor Platzierung prüfen; bei Move zuerst alte Zellen freigeben, dann neue markieren.
* **„Level solved“**: schneller Check via `filledCount === 1296` (inkrementell pflegen) **und** keine Konflikte.
* **Performance**: 36×36 ist klein; Redraw per `requestAnimationFrame`; beim Drag nur Preview schichtenweise.
* **Eingaben**: Maus & Touch via Pointer Events; ESC = Drag abbrechen; +/- = Zoom.
* **Barrierefreiheit**: optional Tastatur-Move eines angewählten Teils in 1-Zellen-Schritten.

## Dateiaufteilung (trotz „single file“ logisch modular)

* `<script type="module">` mit Klassen: `state.js`, `render.js`, `drag.js`, `collision.js` (inline im selben HTML).
* Keine externen Assets/Fonts; alles self-contained.
